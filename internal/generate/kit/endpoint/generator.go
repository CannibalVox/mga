package endpoint

import (
	"bytes"
	"fmt"
	"unicode"

	"github.com/dave/jennifer/jen"
)

// Generate generates a go-kit endpoint struct.
func Generate(pkg string, spec ServiceSpec, withOc bool, ocRoot string, baseName string) (string, error) {
	file := jen.NewFilePath(pkg)

	file.PackageComment("Code generated by mga tool. DO NOT EDIT.")

	file.ImportName("github.com/go-kit/kit/endpoint", "endpoint")
	file.ImportAlias("github.com/sagikazarmark/kitx/endpoint", "kitxendpoint")
	file.ImportName(spec.Package.Path, spec.Package.Name)

	endpointConstBaseName := "Endpoint"
	endpointStructName := "Endpoints"
	endpointFactoryName := "MakeEndpoints"
	endpointTraceFactoryName := "TraceEndpoints"
	if baseName != "" {
		// Make the first letter upper case
		name := string(unicode.ToUpper(rune(baseName[0])))
		if len(baseName) > 1 {
			name += baseName[1:]
		}

		endpointConstBaseName = fmt.Sprintf("%sEndpoint", name)
		endpointStructName = fmt.Sprintf("%sEndpoints", name)
		endpointFactoryName = fmt.Sprintf("Make%sEndpoints", name)
		endpointTraceFactoryName = fmt.Sprintf("Trace%sEndpoints", name)
	}

	endpoints := make([]jen.Code, 0, len(spec.Endpoints))
	endpointDict := jen.Dict{}
	endpointConsts := make([]jen.Code, 0, len(spec.Endpoints))
	for _, endpoint := range spec.Endpoints {
		endpoints = append(endpoints, jen.Id(endpoint.Name).Qual("github.com/go-kit/kit/endpoint", "Endpoint"))
		endpointDict[jen.Id(endpoint.Name)] = jen.Qual("github.com/sagikazarmark/kitx/endpoint", "OperationNameMiddleware").
			Call(jen.Id(fmt.Sprintf("%s%s", endpoint.Name, endpointConstBaseName))).
			Call(
				jen.Id("mw").Call(
					jen.Id(fmt.Sprintf("Make%sEndpoint", endpoint.Name)).Call(jen.Id("service")),
				),
			)
		endpointConsts = append(
			endpointConsts,
			jen.Id(fmt.Sprintf("%s%s", endpoint.Name, endpointConstBaseName)).
				Op("=").
				Lit(fmt.Sprintf("%s.%s", spec.Package.Name, endpoint.Name)),
		)
	}

	file.Comment("Endpoint name constants")
	file.Const().Defs(endpointConsts...)

	file.Commentf("%s collects all of the endpoints that compose the underlying service. It's", endpointStructName)
	file.Comment("meant to be used as a helper struct, to collect all of the endpoints into a")
	file.Comment("single parameter.")
	file.Type().Id(endpointStructName).Struct(endpoints...)

	file.Commentf("%s returns a(n) %s struct where each endpoint invokes", endpointFactoryName, endpointStructName)
	file.Comment("the corresponding method on the provided service.")
	file.Func().Id(endpointFactoryName).
		Params(
			jen.Id("service").Qual(spec.Package.Path, spec.Name),
			jen.Id("middleware").Op("...").Qual("github.com/go-kit/kit/endpoint", "Middleware"),
		).
		Params(jen.Id(endpointStructName)).
		Block(
			jen.Id("mw").
				Op(":=").
				Qual("github.com/sagikazarmark/kitx/endpoint", "Combine").
				Call(jen.Id("middleware").Op("...")),
			jen.Line(),
			jen.Return(
				jen.Id(endpointStructName).Values(endpointDict),
			),
		)

	if withOc {
		file.ImportAlias("github.com/go-kit/kit/tracing/opencensus", "kitoc")

		if ocRoot == "" {
			ocRoot = spec.Package.Name
		}

		endpointDict := jen.Dict{}
		for _, endpoint := range spec.Endpoints {
			endpointDict[jen.Id(endpoint.Name)] = jen.Qual(
				"github.com/go-kit/kit/tracing/opencensus",
				"TraceEndpoint",
			).
				Call(jen.Lit(fmt.Sprintf("%s.%s", ocRoot, endpoint.Name))).
				Call(jen.Id("endpoints").Dot(endpoint.Name))
		}

		file.Commentf(
			"%s returns a(n) %s struct where each endpoint is wrapped with a tracing middleware.",
			endpointTraceFactoryName,
			endpointStructName,
		)
		file.Func().Id(endpointTraceFactoryName).
			Params(jen.Id("endpoints").Id(endpointStructName)).
			Params(jen.Id(endpointStructName)).
			Block(jen.Return(jen.Id(endpointStructName).Values(endpointDict)))
	}

	var buf bytes.Buffer

	err := file.Render(&buf)

	return buf.String(), err
}
