package endpoint

import (
	"bytes"
	"fmt"
	"go/format"

	"github.com/dave/jennifer/jen"

	"sagikazarmark.dev/mga/pkg/gentypes"
)

// File represents one or more services and provides information for generating endpoints for these services.
type File struct {
	gentypes.File

	// EndpointSets represents endpoints to be generated for each service in the package.
	EndpointSets []EndpointSet
}

// EndpointSet represents a set of endpoints for a single service.
// nolint: golint
type EndpointSet struct {
	// Name identifies the endpoint set.
	//
	// Normally, it's generated from the service name by removing the "Service" suffix (if any).
	// That can often result in an empty endpoint set name which is normal for single-service packages.
	Name string

	// Service is a reference to the original service this endpoint set is being generated from.
	Service gentypes.TypeRef

	// Endpoints is the list of endpoints represented by the set.
	Endpoints []Endpoint

	// WithOpenCensus enables generating a trace middleware for the endpoint set.
	WithOpenCensus bool
}

// Endpoint represents an endpoint for a single service call.
// nolint: golint
type Endpoint struct {
	// Name identifies a call within a service.
	Name string

	// OperationName uniquely identifies a service call.
	//
	// When empty it falls back to "packageIdentifier(.endpointSetName)?.endpointName".
	OperationName string
}

// Generate generates Go kit endpoint sets for services.
func Generate(file File) ([]byte, error) {
	code := jen.NewFilePathName(file.Package.Path, file.Package.Name)

	code.HeaderComment("// +build !ignore_autogenerated\n")

	if file.HeaderText != "" {
		code.HeaderComment(file.HeaderText)
	}

	code.HeaderComment("Code generated by mga tool. DO NOT EDIT.")

	code.ImportName("github.com/go-kit/kit/endpoint", "endpoint")
	code.ImportAlias("github.com/sagikazarmark/kitx/endpoint", "kitxendpoint")

	for _, set := range file.EndpointSets {
		generateEndpointSet(code, set)
	}

	var buf bytes.Buffer

	err := code.Render(&buf)
	if err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

func generateEndpointSet(code *jen.File, set EndpointSet) {
	code.ImportName(set.Service.Package.Path, set.Service.Package.Name)

	endpointStructName := fmt.Sprintf("%sEndpoints", set.Name)
	endpointFactoryName := fmt.Sprintf("Make%sEndpoints", set.Name)
	endpointTraceFactoryName := fmt.Sprintf("Trace%sEndpoints", set.Name)

	endpoints := make([]jen.Code, 0, len(set.Endpoints))
	endpointDict := jen.Dict{}
	for _, endpoint := range set.Endpoints {
		endpoints = append(endpoints, jen.Id(endpoint.Name).Qual("github.com/go-kit/kit/endpoint", "Endpoint"))
		endpointDict[jen.Id(endpoint.Name)] = jen.Qual("github.com/sagikazarmark/kitx/endpoint", "OperationNameMiddleware").
			Call(jen.Lit(endpoint.OperationName)).
			Call(
				jen.Id("mw").Call(
					jen.Id(fmt.Sprintf("Make%s%sEndpoint", endpoint.Name, set.Name)).Call(jen.Id("service")),
				),
			)
	}

	code.Commentf("%s collects all of the endpoints that compose the underlying service. It's", endpointStructName)
	code.Comment("meant to be used as a helper struct, to collect all of the endpoints into a")
	code.Comment("single parameter.")
	code.Type().Id(endpointStructName).Struct(endpoints...)

	code.Commentf("%s returns a(n) %s struct where each endpoint invokes", endpointFactoryName, endpointStructName)
	code.Comment("the corresponding method on the provided service.")
	code.Func().Id(endpointFactoryName).
		Params(
			jen.Id("service").Qual(set.Service.Package.Path, set.Service.Name),
			jen.Id("middleware").Op("...").Qual("github.com/go-kit/kit/endpoint", "Middleware"),
		).
		Params(jen.Id(endpointStructName)).
		Block(
			jen.Id("mw").
				Op(":=").
				Qual("github.com/sagikazarmark/kitx/endpoint", "Combine").
				Call(jen.Id("middleware").Op("...")),
			jen.Line(),
			jen.Return(
				jen.Id(endpointStructName).Values(endpointDict),
			),
		)

	if set.WithOpenCensus {
		code.ImportAlias("github.com/go-kit/kit/tracing/opencensus", "kitoc")

		endpointDict := jen.Dict{}
		for _, endpoint := range set.Endpoints {
			endpointDict[jen.Id(endpoint.Name)] = jen.Qual(
				"github.com/go-kit/kit/tracing/opencensus",
				"TraceEndpoint",
			).
				Call(jen.Lit(endpoint.OperationName)).
				Call(jen.Id("endpoints").Dot(endpoint.Name))
		}

		code.Commentf(
			"%s returns a(n) %s struct where each endpoint is wrapped with a tracing middleware.",
			endpointTraceFactoryName,
			endpointStructName,
		)
		code.Func().Id(endpointTraceFactoryName).
			Params(jen.Id("endpoints").Id(endpointStructName)).
			Params(jen.Id(endpointStructName)).
			Block(jen.Return(jen.Id(endpointStructName).Values(endpointDict)))
	}
}
