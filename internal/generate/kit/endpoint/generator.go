package endpoint

import (
	"bytes"
	"fmt"
	"go/format"

	"github.com/dave/jennifer/jen"
)

// Generate generates Go kit endpoint sets for services.
func Generate(pkgDef PackageDefinition) ([]byte, error) {
	file := jen.NewFilePathName(pkgDef.PackagePath, pkgDef.PackageName)

	file.HeaderComment("// +build !ignore_autogenerated\n")

	if pkgDef.HeaderText != "" {
		file.HeaderComment(pkgDef.HeaderText)
	}

	file.HeaderComment("Code generated by mga tool. DO NOT EDIT.")

	file.ImportName("github.com/go-kit/kit/endpoint", "endpoint")
	file.ImportAlias("github.com/sagikazarmark/kitx/endpoint", "kitxendpoint")

	for _, set := range pkgDef.EndpointSets {
		file.ImportName(set.Service.PackagePath, set.Service.PackageName)

		generateEndpointSet(file, pkgDef.LogicalName, set)
	}

	var buf bytes.Buffer

	err := file.Render(&buf)
	if err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

func generateEndpointSet(file *jen.File, pkgName string, set SetDefinition) {
	endpointConstBaseName := fmt.Sprintf("%sEndpoint", set.BaseName)
	endpointStructName := fmt.Sprintf("%sEndpoints", set.BaseName)
	endpointFactoryName := fmt.Sprintf("Make%sEndpoints", set.BaseName)
	endpointTraceFactoryName := fmt.Sprintf("Trace%sEndpoints", set.BaseName)

	endpoints := make([]jen.Code, 0, len(set.Endpoints))
	endpointDict := jen.Dict{}
	endpointConsts := make([]jen.Code, 0, len(set.Endpoints))
	for _, endpoint := range set.Endpoints {
		endpoints = append(endpoints, jen.Id(endpoint.Name).Qual("github.com/go-kit/kit/endpoint", "Endpoint"))
		endpointDict[jen.Id(endpoint.Name)] = jen.Qual("github.com/sagikazarmark/kitx/endpoint", "OperationNameMiddleware").
			Call(jen.Id(fmt.Sprintf("%s%s", endpoint.Name, endpointConstBaseName))).
			Call(
				jen.Id("mw").Call(
					jen.Id(fmt.Sprintf("Make%s%sEndpoint", endpoint.Name, set.BaseName)).Call(jen.Id("service")),
				),
			)
		endpointConsts = append(
			endpointConsts,
			jen.Id(fmt.Sprintf("%s%s", endpoint.Name, endpointConstBaseName)).
				Op("=").
				Lit(fmt.Sprintf("%s.%s", pkgName, endpoint.Name)),
		)
	}

	file.Comment("Endpoint name constants")
	file.Const().Defs(endpointConsts...)

	file.Commentf("%s collects all of the endpoints that compose the underlying service. It's", endpointStructName)
	file.Comment("meant to be used as a helper struct, to collect all of the endpoints into a")
	file.Comment("single parameter.")
	file.Type().Id(endpointStructName).Struct(endpoints...)

	file.Commentf("%s returns a(n) %s struct where each endpoint invokes", endpointFactoryName, endpointStructName)
	file.Comment("the corresponding method on the provided service.")
	file.Func().Id(endpointFactoryName).
		Params(
			jen.Id("service").Qual(set.Service.PackagePath, set.Service.Name),
			jen.Id("middleware").Op("...").Qual("github.com/go-kit/kit/endpoint", "Middleware"),
		).
		Params(jen.Id(endpointStructName)).
		Block(
			jen.Id("mw").
				Op(":=").
				Qual("github.com/sagikazarmark/kitx/endpoint", "Combine").
				Call(jen.Id("middleware").Op("...")),
			jen.Line(),
			jen.Return(
				jen.Id(endpointStructName).Values(endpointDict),
			),
		)

	if set.WithOpenCensus {
		file.ImportAlias("github.com/go-kit/kit/tracing/opencensus", "kitoc")

		endpointDict := jen.Dict{}
		for _, endpoint := range set.Endpoints {
			endpointDict[jen.Id(endpoint.Name)] = jen.Qual(
				"github.com/go-kit/kit/tracing/opencensus",
				"TraceEndpoint",
			).
				Call(jen.Id(fmt.Sprintf("%s%s", endpoint.Name, endpointConstBaseName))).
				Call(jen.Id("endpoints").Dot(endpoint.Name))
		}

		file.Commentf(
			"%s returns a(n) %s struct where each endpoint is wrapped with a tracing middleware.",
			endpointTraceFactoryName,
			endpointStructName,
		)
		file.Func().Id(endpointTraceFactoryName).
			Params(jen.Id("endpoints").Id(endpointStructName)).
			Params(jen.Id(endpointStructName)).
			Block(jen.Return(jen.Id(endpointStructName).Values(endpointDict)))
	}
}
