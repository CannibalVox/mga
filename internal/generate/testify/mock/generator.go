package mock

import (
	"bytes"
	"fmt"
	"go/format"
	"go/types"

	"github.com/dave/jennifer/jen"

	"sagikazarmark.dev/mga/pkg/gentypes"
	"sagikazarmark.dev/mga/pkg/jenutils"
)

// File represents one or more interfaces and provides information for generating mocks for these interfaces.
type File struct {
	gentypes.File

	// Interfaces represents the interfaces that needs to be mocked.
	Interfaces []Interface
}

// Interface represents an interface.
type Interface struct {
	Object *types.TypeName
	Type   *types.Interface
}

// Generate generates Go kit endpoint sets for services.
func Generate(file File) ([]byte, error) {
	code := jen.NewFilePathName(file.Package.Path, file.Package.Name)

	code.HeaderComment("// +build !ignore_autogenerated\n")

	if file.HeaderText != "" {
		code.HeaderComment(file.HeaderText)
	}

	code.HeaderComment("Code generated by mga tool. DO NOT EDIT.")

	code.ImportName("github.com/stretchr/testify/mock", "mock")

	for _, iface := range file.Interfaces {
		generateMock(code, iface)
	}

	var buf bytes.Buffer

	err := code.Render(&buf)
	if err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

func generateMock(code *jen.File, iface Interface) {
	// import the interface package
	code.ImportName(iface.Object.Pkg().Path(), iface.Object.Pkg().Name())

	mockName := fmt.Sprintf("Mock%s", iface.Object.Name())

	code.Commentf("Mock%[1]s is an autogenerated mock for the %[1]s type.", iface.Object.Name())
	code.Type().Id(mockName).Struct(
		jen.Qual("github.com/stretchr/testify/mock", "Mock"),
	)

	for i := 0; i < iface.Type.NumMethods(); i++ {
		method := iface.Type.Method(i)

		sig := method.Type().(*types.Signature)

		const recv = "_m"
		const unnamedParameterPrefix = "_parameter_"
		const unnamedResultPrefix = "_result_"

		code.Commentf("%s provides a mock function.", method.Name())
		code.Func().
			Params(jen.Id(recv).Op("*").Id(mockName)).
			Id(method.Name()).
			ParamsFunc(func(group *jen.Group) {
				params := sig.Params()

				for i := 0; i < params.Len(); i++ {
					param := params.At(i)

					paramName := param.Name()
					if paramName == "" {
						paramName = fmt.Sprintf("%s%d", unnamedParameterPrefix, i)
					}

					jenutils.Import(code, param.Type())
					jenutils.Type(group.Id(paramName), param.Type())
				}
			}).
			ParamsFunc(func(group *jen.Group) {
				results := sig.Results()

				for i := 0; i < results.Len(); i++ {
					result := results.At(i)
					resultName := result.Name()
					if resultName == "" {
						resultName = fmt.Sprintf("%s%d", unnamedResultPrefix, i)
					}

					jenutils.Import(code, result.Type())
					jenutils.Type(group.Id(resultName), result.Type())
				}
			}).
			BlockFunc(func(group *jen.Group) {
				results := sig.Results()

				params := sig.Params()
				var assertParams []jen.Code
				var callParams []jen.Code

				for i := 0; i < params.Len(); i++ {
					param := params.At(i)
					paramName := param.Name()
					if paramName == "" {
						paramName = fmt.Sprintf("%s%d", unnamedParameterPrefix, i)
					}

					assertParams = append(assertParams, jenutils.Type(&jen.Statement{}, param.Type()))
					callParams = append(callParams, jen.Id(paramName))
				}

				if results.Len() == 0 {
					group.Id(recv).Dot("Called").Call(callParams...)

					return
				}

				group.Id("ret").Op(":=").Id(recv).Dot("Called").Call(callParams...)
				group.Line()

				var returns []jen.Code

				for i := 0; i < results.Len(); i++ {
					i := i

					result := results.At(i)

					r := fmt.Sprintf("r%d", i)
					returns = append(returns, jen.Id(r))

					jenutils.Type(group.Var().Id(r), result.Type())

					group.If(
						jen.Id("rf").Op(",").Id("ok").
							Op(":=").
							Id("ret").Dot("Get").Call(jen.Lit(i)).
							Assert(jen.Func().Params(assertParams...).Params(jenutils.Type(&jen.Statement{}, result.Type()))),
						jen.Id("ok"),
					).Block(
						jen.Id(r).Op("=").Id("rf").Call(callParams...),
					).Else().BlockFunc(func(group *jen.Group) {
						// TODO: find a better way to determine if a type represents an error
						if result.Type().String() == "error" {
							group.Id(r).Op("=").Id("ret").Dot("Error").Call(jen.Lit(i))
						} else {
							retValCode := jen.Id(r).Op("=").Id("ret").Dot("Get").Call(jen.Lit(i)).
								Assert(jenutils.Type(&jen.Statement{}, result.Type()))

							if jenutils.IsNillable(result.Type()) {
								group.If(jen.Id("ret").Dot("Get").Call(jen.Lit(i)).Op("!=").Nil()).Block(retValCode)
							} else {
								group.Add(retValCode)
							}
						}
					})

					group.Line()
				}

				group.Return(returns...)
			}).
			Line()
	}
}
